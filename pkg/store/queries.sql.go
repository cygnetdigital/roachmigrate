// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: queries.sql

package store

import (
	"context"
	"database/sql"
)

const create = `-- name: Create :one
INSERT INTO roach_migrations (id, key, filename) VALUES ($1, $2, $3) RETURNING id, key, filename, completed, failed, fail_reason, created_at, updated_at
`

type CreateParams struct {
	ID       string
	Key      string
	Filename string
}

func (q *Queries) Create(ctx context.Context, db DBTX, arg CreateParams) (RoachMigration, error) {
	row := db.QueryRow(ctx, create, arg.ID, arg.Key, arg.Filename)
	var i RoachMigration
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Filename,
		&i.Completed,
		&i.Failed,
		&i.FailReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const list = `-- name: List :many
SELECT id, key, filename, completed, failed, fail_reason, created_at, updated_at FROM roach_migrations WHERE key = $1 ORDER BY created_at
`

func (q *Queries) List(ctx context.Context, db DBTX, key string) ([]RoachMigration, error) {
	rows, err := db.Query(ctx, list, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoachMigration
	for rows.Next() {
		var i RoachMigration
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Filename,
			&i.Completed,
			&i.Failed,
			&i.FailReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForUpdate = `-- name: ListForUpdate :many
SELECT id, key, filename, completed, failed, fail_reason, created_at, updated_at FROM roach_migrations WHERE key = $1 ORDER BY created_at FOR UPDATE
`

func (q *Queries) ListForUpdate(ctx context.Context, db DBTX, key string) ([]RoachMigration, error) {
	rows, err := db.Query(ctx, listForUpdate, key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RoachMigration
	for rows.Next() {
		var i RoachMigration
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Filename,
			&i.Completed,
			&i.Failed,
			&i.FailReason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update = `-- name: Update :one
UPDATE roach_migrations SET completed = $1, failed = $2, fail_reason = $3 WHERE id = $4 RETURNING id, key, filename, completed, failed, fail_reason, created_at, updated_at
`

type UpdateParams struct {
	Completed  bool
	Failed     bool
	FailReason sql.NullString
	ID         string
}

func (q *Queries) Update(ctx context.Context, db DBTX, arg UpdateParams) (RoachMigration, error) {
	row := db.QueryRow(ctx, update,
		arg.Completed,
		arg.Failed,
		arg.FailReason,
		arg.ID,
	)
	var i RoachMigration
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Filename,
		&i.Completed,
		&i.Failed,
		&i.FailReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
